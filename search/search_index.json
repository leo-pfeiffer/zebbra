{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Zebbra","text":"<p>Zebbra</p> <p>Zebbra API</p> <p>Zebbra API Docs</p>"},{"location":"#overview","title":"Overview","text":"<p>This documentation includes the following sections:</p> <p>The Tutorial provides a brief user-oriented introduction to how to use Zebbra.</p> <p>The Project Setup guide provides a step-by-step guideline of how to start running the different components of the Zebbra application. This is especially useful for local testing and development.</p> <p>The OAuth 2.0 Authentication section shifts the focus to the actual use of the Zebbra API by providing an overview of the OAuth workflow to authenticate client requests.</p> <p>In the Integration Guide, the steps to adding a new third-party integration are detailed.</p> <p>The Gusto Integration Example provides an example of how to use the integration guide of by applying it to the implementation of the Gusto application.</p> <p>In the Deployment section, all steps necessary to deploy both the front end as well as the back end to a production server is provided.</p>"},{"location":"add_integration/","title":"Integration Guide","text":"<p>Zebbra was built with the fact in mind, that different organizations use different systems for their payroll and accounting. Thus, it is possible to extend Zebbra by adding support for any other integration provider for either payroll or accounting management, as long as they offer an OAuth 2 authenticated REST API. This guide walks through the process of adding a new integration.</p>"},{"location":"add_integration/#adding-a-new-integration","title":"Adding a new integration","text":""},{"location":"add_integration/#0-automatic-starter-template-generation","title":"0. Automatic starter template generation","text":"<p>To facilitate the implementation process, we provide a script to generate starter files from templates. To get started simply run <code>make genereate_from_template INTEGRATION=&lt;integration_name&gt; API_TYPE=&lt;payroll | accounting&gt;</code> from the <code>server</code> directory.</p> <p>This will generate the required starter files in the <code>core/integrations/adapters</code>and <code>core/integrations/oauth</code> directories.</p>"},{"location":"add_integration/#1-extending-the-integrationprovider-type","title":"1. Extending the <code>IntegrationProvider</code> type","text":"<p>The <code>IntegrationProvider</code> type is used across Zebbra as a type for valid integration provider names. To add a new provider, add its name to the <code>IntegrationProvider</code> variable in <code>core/schemas/integrations.py</code>. Note that the name must be strictly alphanumeric (i.e. <code>[A-Za-z0-9]+</code>).</p>"},{"location":"add_integration/#2-adding-oauth-connector-class","title":"2. Adding OAuth connector class","text":"<p>Secondly, you need to set up the OAuth authorization functionality for the OAuth app you want to integrate. Zebbra provides a framework for this with the abstract class <code>IntegrationOAuth</code>, which you can override to set up the workflow.</p> <p>To set up a new integration workflow, create a new file in <code>core/integrations/oauth</code> with a class that inherits from <code>core.integrations.oauth.integration_oauth.IntegrationOAuth</code>. Crucially, you will need to implement at least the following methods.</p> <ul> <li> <p>Override <code>_perform_token_refresh(...)</code>.  This method defines the refresh workflow for a token refresh for apps that have been authenticated before, but whose access token has expired. The method is highly dependent on the integration you're integrating. In general, however, the method should call the refresh URL of the OAuth app and update the existing OAuth token information with the new one.</p> </li> <li> <p>Override <code>_store_oauth_token(...)</code>. This method stores the OAuth token information as an <code>IntegrationAccess</code> object in the  database. This is a relatively simple operation, but can depend on the specific OAuth app.</p> </li> </ul> <p>When you set up your OAuth app on the side of the provider,  you will be asked to provide the Callback URL, to which the OAuth server redirects you to after authorization. <code>IntegrationOAuth</code> autogenerates these URLs following the pattern <code>http://&lt;host&gt;/integration/&lt;integration_name&gt;/callback</code>.  Note that the integration name is put to lower case. </p> <p>Similarly, <code>IntegrationOAuth</code> autogenerates the URL that your client can call to perform the login to the OAuth app. The login URL follows the pattern <code>http://&lt;host&gt;/integration/&lt;integration_name&gt;/login</code>.</p> <p>Now, create an instance of this class in the same file, which will be used by other parts of the application as appropriate. On this instance, call the <code>register_oauth_app</code> method, which is used to configure the OAuth app through the authlib starlette client. The method takes the same arguments as <code>authlib.integrations.starlette_client.OAuth.register</code>. See the authlib documentation for details on what to pass to the method.  After registering, the OAuth app is available as an instance variable as IntegrationAccess.oauth_app.</p> <p>Lastly, you need to create the FastAPI routes for the OAuth login and callback. The body of these functions is already implemented in <code>IntegrationOAuth</code>, you only have to define the routes using the instance created in the previous step. Assuming your instance is called <code>xxx</code>, add the following to the bottom of the file:</p> <pre><code>@xxx.router.get(**xxx.login_endpoint())  \nasync def login_route(  \n    workspace_id: str,  \n    request: Request,  \n    current_user: User = Depends(get_current_active_user_url),  \n):  \n    return await xxx.oauth_login(workspace_id, request, current_user)\n\n\n@xxx.router.get(**xxx.callback_endpoint())  \nasync def callback_route(request: Request):  \n    return await xxx.oauth_callback(request)\n</code></pre>  <p>It is highly recommended to use the code generator script described above to generate this starter file automatically.</p>  <p>With this, your clients can now connect to the integration by visiting the <code>http://&lt;host&gt;/integration/&lt;integration_name&gt;/login</code> endpoint.</p>  <p>When the client accesses one of these endpoints, the OAuth (to authenticate with the Zebbra API) does not work via the usual authorization header. Rather the client has to specify the <code>access_token</code> query parameter, which should contain the Zebbra OAuth access token normally sent in the header. For example, a client might call call the following URL: </p> <p><code>http://localhost:8000/integration/xero/login?workspace_id=123&amp;access_token=a1b2c3</code>.</p>"},{"location":"add_integration/#3-adding-fetch-adapter","title":"3. Adding fetch adapter","text":"<p>With the OAuth authorization flow set up, we can implement the fetch adapter, which is responsible for fetching the data from the integrated app. As before, we provide an abstract class <code>core.integrations.adapters.adapter.FetchAdapter</code>, which should be inherited from by a class that implements its abstract methods.</p> <p>Fetch adapters differ slightly depending if the API is a payroll vs an accounting API. In either case, create a new file in <code>core/integrations/adapters</code> and add a class that inherits from <code>FetchAdapter</code>. You will have to override at least the following methods:</p> <ul> <li> <p>Implement the <code>get_data</code> method, which is the main method called during the merging procedure where the  integration data is added to the models.  The method implement the  process to retrieve the data from the integration API or a cache. Then, in the case of an accounting API the data is converted into a DataBatch object. In the case of a payroll API, a list of Employee objects is created and returned.</p> </li> <li> <p>Implement the <code>get_data_endpoints</code> method, which returns a list of available data endpoints for the integration. The method usually makes a call to the integration API to retrieve the available endpoints. This data can easily be cached, and given the frequency with which this endpoint is called, implementing caching greatly improves performance.</p> </li> </ul>  <p>It is highly recommended to use the code generator script described above to generate this starter file automatically.</p>"},{"location":"add_integration/#4-update-config","title":"4. Update config","text":"<p>At this stage, all core classes have now been implemented. What remains is to let the rest of the application now about the new integrations. This happens via a few additions to the <code>core/integrations/config.py</code> file.</p> <p>Add the following lines to the <code>setup_integrations</code> function inside the file. <pre><code>def setup_integrations(app: FastAPI):  \n    # register the FetchAdapter implementation *class* here  \n    _register_adapter(XeroFetchAdapter)\n    _register_adapter(MyNewIntegrationFetchAdapter)  # ADD THIS\n\n    # register the IntegrationOAuth implementation *instance* here \n    _register_oauth(xero_integration_oauth)\n    _register_oauth(my_new_integration_oauth_instance)  # ADD THIS\n\n    ...\n</code></pre></p> <p>What happens here, is that the <code>_register_adapter</code> function keeps track of the <code>FetchAdapter</code> implementation classes, while the <code>_regiter_oauth</code> function keeps track of the instances of the <code>IntegrationOAuth</code> implementations.</p> <p>This <code>setup_integrations</code> function is then automatically called during the setup of the app and registers the integration for consideration during calls to the Zebbra API.</p>"},{"location":"deployment/","title":"Deploying the Zebbra API (and front end)","text":"<p>Users are encouraged to deploy their own instance of the Zebbra API. This way, you have controll over your own data (and our deployment has to cope with less traffic).</p> <p>We will deploy the API using gunicorn as the application server, and NGINX as the reverse proxy to handle HTTPS etc.</p> <p>This deployment guide was tested on Ubuntu 20.04.</p> <p>The deployment guide assumes the following:</p> <ul> <li>Logged in as superuser with username <code>zebbra</code></li> <li>Python 3.10 is installed and the default Python version. We recommend using pyenv (how to)</li> <li>Mongo DB Community edition version 5.0 is installed and running (how to)</li> </ul> <p>We further assume that you start out in the user's home directory <code>/home/zebbra</code>.</p>   <p>Much of this guide was based on similar tutorials by DigitalOcean and Vultr.</p>"},{"location":"deployment/#project-set-up","title":"Project set up","text":"<p>The project setup is similar to the setup for local development, so if you've set up the project locally before, feel free to step this step. </p>"},{"location":"deployment/#repository-and-virtual-environment","title":"Repository and virtual environment","text":"<p>Start by cloning the repository, setting up a virtual environment and installing the required dependencies.</p> <pre><code># /home/zebbra\n\n# clone the repository\ngit clone git@github.com:leo-pfeiffer/zebbra.git\n\n# set up virtual environment\ncd zebbra/server\npython -m venv venv\nsource venv/bin/activate\n\n# install dependencies\nmake requirements\n</code></pre>"},{"location":"deployment/#env-file","title":"<code>.env</code> file","text":"<p>Next, create the <code>.env</code> file with the environment variables. Run the following to create a file with the starter template. You will have to fill out the missing variable assignments (e.g. secrets etc.).</p> <pre><code># /home/zebbra/zebbra/server\n\ncat &lt;&lt;EOF &gt; .env\n# VALIDATION\nENV_SET=\"true\"\n\n# BASE URL\nZEBBRA_BASE_URL=\n#ZEBBRA_BASE_URL=\"http://localhost:8000\"\n\n# SETTINGS\nENV_ENCRYPT_PASS=\n\n# AUTH\nAUTH_SECRET=\nAUTH_ALGO=\"HS256\"\n# 30 days in minutes\nAUTH_TOKEN_EXPIRE=43200\n\n# MONGO DB\nMONGODB_USER=\nMONGODB_DB=\nMONGODB_PW=\nMONGODB_URL=\"127.0.0.1:27017\"\n\n# XERO\nXERO_CLIENT_ID=\nXERO_CLIENT_SECRET=\n\n# GUSTO\nGUSTO_CLIENT_ID=\nGUSTO_CLIENT_SECRET=\n\n# CACHE\n# 24 hrs in seconds\nCACHE_TTL=86400\nEOF\n</code></pre>"},{"location":"deployment/#database","title":"Database","text":"<p>If you've set up the <code>.env</code> file correctly, you can use the default script to set up the database.</p> <pre><code># /home/zebbra/zebbra/server\n\nmake setup_db\n</code></pre> <p>This creates the required users, sets up the indexes for caching, and loads some demo data.</p>"},{"location":"deployment/#checkpoint","title":"\ud83d\udea9 Checkpoint","text":"<p>At this point you should be able to run the app with gunicorn.</p> <pre><code>gunicorn --bind 0.0.0.0:5000 main:app -k uvicorn.workers.UvicornWorker\n</code></pre> <p>Head to <code>http://your-domain.com:5000</code> (remember to allow port 5000 in your firewall first).</p>"},{"location":"deployment/#setting-up-the-zebbra-service","title":"Setting up the Zebbra service","text":"<p>Next, we will have to set up the Zebbra service that will later be run by NGINX.</p>"},{"location":"deployment/#service-configuration","title":"Service configuration","text":"<p>Run</p> <pre><code>sudo nano /etc/systemd/system/zebbra.service\n</code></pre> <p>and paste the following:</p> <pre><code>[Unit]\nDescription=Gunicorn instance to serve Zebbra API\nAfter=network.target\n\n[Service]\nUser=zebbra\nGroup=www-data\nWorkingDirectory=/home/zebbra/zebbra/server\nEnvironment=\"PATH=/home/zebbra/zebbra/server/venv/bin\"\nExecStart=/home/zebbra/zebbra/server/venv/bin/gunicorn --workers 3 --bind unix:zebbra.sock -m 007 main:app -k uvicorn.workers.UvicornWorker --forwarded-allow-ips=\"*\"\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"deployment/#start-and-enable-the-service","title":"Start and enable the service","text":"<p>With the service configuration in place, we can sart and enable the Zebbra service.</p> <pre><code>sudo systemctl start zebbra\nsudo systemctl enable zebbra\n</code></pre>"},{"location":"deployment/#checkpoint_1","title":"\ud83d\udea9 Checkpoint","text":"<p>You can confirm that all is well by runing <code>sudo systemctl status zebbra</code>. Your Zebbra service is running.</p>"},{"location":"deployment/#set-up-nginx","title":"Set up NGINX","text":"<p>We can now proceed to set up NGINX.</p>"},{"location":"deployment/#installing-nginx","title":"Installing NGINX","text":"<p>If you don't already have NGINX installed on your server, you can do so like this:</p> <pre><code>sudo apt update\nsudo apt install nginx\nsudo ufw allow 'Nginx HTTP'\n</code></pre>"},{"location":"deployment/#create-the-zebbra-site","title":"Create the Zebbra site","text":"<p>With NGINX installed, we can add the Zebbra site.</p> <p>Run</p> <pre><code>sudo nano /etc/nginx/sites-available/zebbra\n</code></pre> <p>and paste the following content. Remember to change <code>your_domain</code> to your actual domain.</p> <pre><code>server {\n   listen 80;\n   server_name your_domain www.your_domain;\n\n   location / {\n       include proxy_params;\n       proxy_pass http://unix:/home/zebbra/zebbra/server/zebbra.sock;\n   }\n}\n</code></pre> <p>This site can now be enabled by setting up a symlink.</p> <pre><code>sudo ln -s /etc/nginx/sites-available/zebbra /etc/nginx/sites-enabled\n</code></pre> <p>You can confirm that the file is correctly formatted by running <code>sudo nginx -t</code>.</p> <p>We now need to restart the NGINX service to pick up the Zebbra service.</p> <pre><code>sudo systemctl restart nginx\n</code></pre>"},{"location":"deployment/#update-firewall","title":"Update firewall","text":"<p>Lastly, we need to update the firewall to allow full access to NGINX.</p> <pre><code>sudo ufw allow 'Nginx Full'\n</code></pre>"},{"location":"deployment/#checkpoint_2","title":"\ud83d\udea9 Checkpoint","text":"<p>The Zebbra API should now be deployed and accessible via <code>http://your_domain</code>.</p>"},{"location":"deployment/#setting-up-https","title":"Setting up HTTPS","text":"<p>Since Zebbra handles financial data, security is paramount. In this step, access to the Zebbra API is secured with HTTPS. We will use a free Let's Encrypt certificate.</p> <p>First, install the python certbot for NGINX.</p> <pre><code>sudo apt install python3-certbot-nginx\n</code></pre> <p>Next, request and generate a SSL certificate.</p> <pre><code>sudo certbot --nginx -d your_domain.xyz -d www.your_domain\n</code></pre> <p>When prompted, accept the T&amp;Cs and select (2) to redirect all HTTP requests to HTTPS automatically.</p> <p>Lastly, we can revoke the NGINX HTTP permission from the firewall again.</p> <pre><code>sudo ufw delete allow 'Nginx HTTP'\n</code></pre>"},{"location":"deployment/#checkpoint_3","title":"\ud83d\udea9 Checkpoint","text":"<p>You're done deploying the API! If everything went well, you can now access the Zebbra API on <code>https://your_domain</code>.</p>"},{"location":"deployment/#deploying-the-zebbra-front-end","title":"Deploying the Zebbra front end","text":"<p>Since the Zebbra front end is implemented as a Nuxt.js app, you can deploy it just as every other Nuxt.js out there. We recommend deploying via Netlify, which is free and works entirely out of the box. A guide is provided in the official Nuxt documentation. The only necessary modification will be to set the environment variable <code>BACKEND_URL_BASE</code>  of the front end to the URL on which your instance of the Zebbra API is deployed.</p>"},{"location":"deployment/#done","title":"\ud83c\udfc1 Done!","text":""},{"location":"gusto_example/","title":"Gusto Integration Example","text":"<p>This example demonstrates the process of integrating a new payroll API using Gusto. Gusto is integrated into Zebbra by default - so this guide is simply a walkthrough and may server as reference for integrating other payroll APIs.</p>"},{"location":"gusto_example/#setup","title":"Setup","text":"<p>We assume that you've already created a Gusto developer account and have registered your application. </p> <p>Start by adding the client ID and client secret issued during the registration to the <code>.env</code> file.</p> <pre><code># .env\n\nGUSTO_CLIENT_ID: mySecretClientId\nGUSTO_CLIENT_SECRET: mySecretClientSecret\n</code></pre> <p>Secondly, we add the Gusto specific URLs to our settings module. The client ID and secret will be retrieved from the <code>.env</code> file.</p> <pre><code># core/settings.py &gt;\n\nclass Settings(BaseSettings):\n    ...\n    GUSTO_CLIENT_ID: str\n    GUSTO_CLIENT_SECRET: str\n    GUSTO_CONF_URL: str = \"https://api.gusto-demo.com/.well-known/openid-configuration\"\n    GUSTO_API_BASE_URL: str = \"https://api.gusto-demo.com/\"\n    GUSTO_REFRESH_URL: str = \"https://api.gusto-demo.com/oauth/token\"\n    GUSTO_AUTHORIZE_URL: str = \"https://api.gusto-demo.com/oauth/authorize\"\n    ...\n</code></pre> <p>Next, we can add Gusto to the list of integration providers, in <code>core/schemas/integrations.py</code>.</p> <pre><code>IntegrationProvider = Literal[\"Xero\", \"Gusto\"]\n</code></pre>"},{"location":"gusto_example/#using-the-template-generator","title":"Using the template generator","text":"<p>We provide a code generator that creates the code for the fetch adapter and oauth integration from a template.</p> <pre><code># zebbra/server\n\n$ make generate_from_template INTEGRATION=Gusto API_TYPE=payroll\n\nGenerating files for integration Gusto...\nUsing payroll templates...\nCreated file: core/integrations/oauth/gusto_oauth.py\nCreated file: core/integrations/adapters/gusto_adapter.py\n</code></pre> <p>As visible in the output, the script creates two files, one for the oauth integration and one for the fetch adapter.</p>"},{"location":"gusto_example/#implementing-the-oauth-integration","title":"Implementing the OAuth integration","text":"<p>In the auto-generated file <code>core/integrations/oauth/gusto_oauth.py</code> file we can now implement the Gusto specific  methods in the <code>GustoIntegrationOAuth</code> class</p>"},{"location":"gusto_example/#implementing-the-_perform_token_refresh-method","title":"Implementing the <code>_perform_token_refresh</code> method","text":"<p>The <code>_perform_token_refresh</code> method is responsible for performing the OAuth refresh workflow in case the current access token has expired. The method uses the Authlib oauth_app instance of the class to send a post request to the Gusto refresh URL. The specifics of this can usually be found in the API documentation of the API you'd like to integrate.</p> <p>The following is the implementation of the <code>_perform_token_refresh</code> method. The methods <code>_process_refresh_response</code> and <code>_store_oauth_token</code> which it calls will be explained later</p> <pre><code># define the token refresh flow\nasync def _perform_token_refresh(self, integration_access: IntegrationAccess):\n\n    # start by making a POST request to the login url\n    response = await self.oauth_app.post(  \n        settings.GUSTO_REFRESH_URL,  # for Gusto, LOGIN_URL = REFRESH_URL\n        data={  \n            \"client_id\": settings.GUSTO_CLIENT_ID,  \n            \"client_secret\": settings.GUSTO_CLIENT_SECRET,  \n            \"redirect_uri\": f\"{settings.ZEBBRA_BASE_URL}/integration/gusto/callback\",\n            \"refresh_token\": integration_access.token.refresh_token,  \n            \"grant_type\": \"refresh_token\",  \n        },  \n    )  \n\n    # process the response to extract the token\n    token = await self._process_refresh_response(response, integration_access)  \n\n    # update token in DB\n    await self._store_oauth_token(integration_access.workspace_id, token)\n\n    # return the new integration access object\n    return await get_integration_for_workspace(  \n        integration_access.workspace_id, self.integration()  \n    )  \n</code></pre> <p>Lots of the heavy lifting in the <code>_perform_token_refresh</code> method is actually done by the helper method <code>_process_refresh_response</code>, which extracts the new token from the response of the call to the refresh URL.</p> <p>We can implement it like this:</p> <pre><code># helper method to extract token from authorize response\nasync def _process_refresh_response(self, response, integration_access: IntegrationAccess) -&gt; IntegrationAccessToken:\n\n  # if status is ok, simply take the response body\n  if response.status_code == 200:  \n        token_data = response.json()\n        if \"expires_at\" not in token_data:  \n            token_data[\"expires_at\"] = token_data[\"expires_in\"] + int(time.time())  \n        return IntegrationAccessToken(**token_data)  \n\n  # Can't refresh token -&gt; set the requires_reconnect value of the integration  \n  #  access to True, indicating that the user has to go through the OAuth \n  #  connection workflow to reconnect the integration. The integration access ID \n  #  remains the same.  \n  await set_requires_reconnect(\n      integration_access.workspace_id,self.integration(), True\n  )\n\n  raise HTTPException(  \n      status_code=status.HTTP_400_BAD_REQUEST,  \n      detail=\"Token refresh failed.\",  \n  )\n</code></pre>"},{"location":"gusto_example/#implementing-the-_store_oauth_token-method","title":"Implementing the <code>_store_oauth_token</code> method","text":"<p>Next, we also need to implement the <code>_store_oauth_token</code> method, which stores the new access token in the database. This works almost the same for every API, however, Gusto differentiates between different company's (or tenants). Zebbra currently only allows a single company, the ID of which must be retrieved from the Gusto API first.</p> <p>Below is the implementation of the <code>_store_oauth_token</code> method together with the <code>get_company</code> method to get the company ID.</p> <pre><code># implement method to store the new token in the DB\nasync def _store_oauth_token(self, workspace_id, token: IntegrationAccessToken):\n    tenant_id = await self.get_company(workspace_id, token.dict())\n\n    integration_access = IntegrationAccess(\n        integration=self.integration(),\n        workspace_id=workspace_id,\n        token=token,\n        tenant_id=tenant_id,\n        requires_reconnect=False,\n    )\n\n    return await add_integration_for_workspace(integration_access)\n\nasync def get_company(self, workspace_id, token: dict | None = None):\n    \"\"\"\n    Get the first available company ID\n    :param workspace_id: Workspace for which to get the xero data.\n    :param token: OAuth token. If not provided, it is retrieved from the DB.\n    :return: Tenant ID\n    \"\"\"\n    if token is None:\n        integration_access = await self.get_integration_access(workspace_id)\n        token = integration_access.token.dict()\n    if not token:\n        return None\n    resp = await self.oauth_app.get(\"v1/me\", token={**token})\n    resp.raise_for_status()\n\n    data = resp.json()\n    if \"payroll_admin\" in (roles := data[\"roles\"]):\n        if \"companies\" in (payroll_admin := roles[\"payroll_admin\"]):\n            if len(payroll_admin[\"companies\"]) != 0:\n                return payroll_admin[\"companies\"][0][\"uuid\"]\n    return None\n</code></pre> <p>This concludes the implementation of the OAuth integration.</p>"},{"location":"gusto_example/#creating-an-instance-of-the-oauth-integration","title":"Creating an instance of the OAuth integration","text":"<p>Having implemented the OAuth integration, we can now create an instance of it in the same file (<code>zebbra/server/core/integrations/oauth/gusto_oauth.py</code>). The stubs for this are already generated automatically, you simply have to fill in the Gusto specific details.</p> <p>Create instance and register OAuth app <pre><code>gusto_integration_oauth = GustoIntegrationOAuth()  \n\n# here we use the settings from settings.py\ngusto_integration_oauth.register_oauth_app(\n    name=\"Gusto\",\n    client_id=settings.GUSTO_CLIENT_ID,\n    client_secret=settings.GUSTO_CLIENT_SECRET,\n    server_metadata_url=settings.GUSTO_CONF_URL,\n    api_base_url=settings.GUSTO_API_BASE_URL,\n    authorize_url=settings.GUSTO_AUTHORIZE_URL,\n    access_token_url=settings.GUSTO_REFRESH_URL,\n)\n</code></pre></p>"},{"location":"gusto_example/#setting-up-the-endpoints-auto-generated","title":"Setting up the endpoints (auto-generated)","text":"<p>You will notice that the endpoints are automatically generated at the bottom of the file.</p>"},{"location":"gusto_example/#registering-the-integration","title":"Registering the integration","text":"<p>We need to let the Zebbra API know about the integration we just implemented. This can be done in the <code>zebbra/server/core/integrations/config.py</code> file by adding the <code>GustoIntegrationOAuth</code> instance we created in the previous steps.</p> <p>Change the file to include the following:</p> <pre><code># core/integrations/config.py\n\n# import the oauth integration instance\nfrom core.integrations.oauth.gusto_oauth import gusto_integration_oauth  # add this\n\n...\n\ndef setup_integrations(app: FastAPI):\n    ...\n    # register the IntegrationOAuth implementation instance here  \n    _register_oauth(gusto_integration_oauth)  # add this\n    ...\n</code></pre>"},{"location":"gusto_example/#checkpoint-oauth-integration-done","title":"\ud83d\udea9 Checkpoint: OAuth integration done","text":"<p>Hooray, we can now authenticate ourselves to the Gusto API!</p> <p>Let's fire up the Fast API server and head to the login endpoint for a workspace and an access token (you will have to fill in actual values).</p> <pre><code>URL: http://localhost:8000/integration/gusto/login?workspace_id=123&amp;access_token=a1b2c3\n</code></pre>"},{"location":"gusto_example/#implementing-the-fetch-adapter","title":"Implementing the Fetch Adapter","text":"<p>In the second part, we set up the fetch adapter responsible for retrieving the payroll data from the Gusto API.</p> <p>We start by implementing the stubbed methods of the auto-generated <code>zebbra/server/core/integrations/adapters/gusto_adapter.py</code> file.</p>"},{"location":"gusto_example/#implementing-get_data","title":"Implementing <code>get_data</code>","text":"<p>Most crucially, the <code>get_data</code> method retrieves the data from the API and converts it into the required format of a list of Employees. Recall that an <code>Employee</code> object has the following format:</p> <pre><code>Employee:\n    id: str\n    name: str\n    start_date: DateString\n    end_date: DateString | None\n    title: str\n    department: str\n    monthly_salary: int\n    from_integration: bool\n</code></pre> <p>Ignoring the helper methods for now, the <code>get_data</code> method looks like this.</p> <pre><code>async def get_data(self, from_date: date) -&gt; list[Employee]:\n\n    # return empty list if gusto is not configured for the workspace\n    if not await workspace_has_integration(self.workspace_id, self.integration()):\n        return []\n\n    # check if we can use cache\n    cache_date = self._cache_date(from_date)\n    if cached := await self.get_cached(cache_date):\n        return cached\n\n    # if no cache, retrieve from Xero API\n    employees = await self._get_employees()\n\n    # convert into the required format\n    processed = self._process_employees(employees, from_date)\n\n    # cache for next time\n    await self.set_cached(processed, cache_date)\n\n    return processed\n</code></pre> <p>Firstly, note that the methods <code>_cache_date</code>, <code>get_cached</code> and <code>set_cached</code> are implemented in the abstract parent class. Thus, the cacheing part of the method should be fairly similar accross integrated APIs.</p> <p>Hence, what remains to be implemented is the <code>_get_employees</code> and <code>_process_employees</code> methods.</p> <p>The <code>_get_employees</code> method uses the <code>IntegrationAccess</code> object for Gusto and fires another <code>get</code> request to the Gusto API, using the <code>oauth_app</code> attached to the adapter class. The response is then converted from JSON and returned.</p> <pre><code>async def _get_employees(self):\n\n    # get the integration access object containing the Gusto credentials\n    integration_access = await gusto_integration_oauth.get_integration_access(\n        self.workspace_id\n    )\n\n    # get the employees data from the Gusto API\n    resp = await gusto_integration_oauth.oauth_app.get(\n        f\"v1/companies/{integration_access.tenant_id}/employees\",\n        token=integration_access.token.dict(),\n        headers={\n            \"Accept\": \"application/json\",\n            \"Content-Type\": \"application/json\",\n        },\n    )\n\n    # Raise error if status is not 200\n    resp.raise_for_status()\n\n    # convert to dict and return\n    return resp.json()\n</code></pre> <p>The <code>_process_employees</code> method now takes this dictionary and converts it into the required format of <code>list[Employee]</code>. This is quite the laborious process and putting it into this documentation would be more harmful than helpful. However, feel free to inspect the relevant method in the <code>zebbra/server/core/integrations/adapters/gusto_adapter.py</code> in more detail, which is extensively commented.</p>"},{"location":"gusto_example/#registering-the-adapter","title":"Registering the adapter","text":"<p>As with the OAuth integration class, we need to let the Zebbra API know about the adapter we just implemented. This can be done in the <code>zebbra/server/core/integrations/config.py</code> file by adding the <code>GustoFetchAdapter</code> class we created in the previous steps.</p> <p>Change the file to include the following:</p> <pre><code># core/integrations/config.py\n\n# import the adapter class\nfrom core.integrations.adapters.gusto_adapter import GustoFetchAdapter  # add this\n\n...\n\ndef setup_integrations(app: FastAPI):\n    ...\n    # register the GustoFetchAdapter implementation class here  \n    _register_adapter(GustoFetchAdapter)  # add this\n</code></pre>"},{"location":"gusto_example/#checkpoint-fetch-adapter-done","title":"\ud83d\udea9 Checkpoint: Fetch adapter done","text":"<p>With this the fetch adapter is fully implemented and registered. The payroll integration is now automatically used by the model endpoint.</p>"},{"location":"gusto_example/#conclusion","title":"\ud83c\udfc1 Conclusion","text":"<p>Now, when the user accesses the <code>GET /model/payroll</code> endpoint (after authorizing Zebbra with Gusto), payroll will be returned:</p> <pre><code>{\n  \"payroll_values\": [\n    {\n      \"date\": \"2021-06-30\",\n      \"value\": \"0\"\n    },\n    {\n      \"date\": \"2021-07-31\",\n      \"value\": \"52712.903225806454\"\n    },\n    {\n      \"date\": \"2021-08-31\",\n      \"value\": \"81705.0\"\n    },\n    {\n      \"date\": \"2021-09-30\",\n      \"value\": \"81705.0\"\n    },\n    {\n      \"date\": \"2021-10-31\",\n      \"value\": \"81705.0\"\n    },\n    {\n      \"date\": \"2021-11-30\",\n      \"value\": \"81705.0\"\n    },\n    {\n      \"date\": \"2021-12-31\",\n      \"value\": \"81705.0\"\n    },\n    {\n      \"date\": \"2022-01-31\",\n      \"value\": \"81705.0\"\n    },\n    {\n      \"date\": \"2022-02-28\",\n      \"value\": \"81705.0\"\n    },\n    {\n      \"date\": \"2022-03-31\",\n      \"value\": \"81705.0\"\n    },\n    {\n      \"date\": \"2022-04-30\",\n      \"value\": \"81705.0\"\n    },\n    {\n      \"date\": \"2022-05-31\",\n      \"value\": \"81705.0\"\n    },\n    {\n      \"date\": \"2022-06-30\",\n      \"value\": \"81705.0\"\n    },\n    {\n      \"date\": \"2022-07-31\",\n      \"value\": \"86046.1935483871\"\n    }\n  ],\n  \"employees\": [\n    {\n      \"_id\": \"123\",\n      \"name\": \"North West\",\n      \"start_date\": \"2021-07-12\",\n      \"end_date\": null,\n      \"title\": \"CEO\",\n      \"department\": \"Management\",\n      \"monthly_salary\": 3810,\n      \"from_integration\": false\n    },\n    {\n      \"_id\": \"456\",\n      \"name\": \"North West\",\n      \"start_date\": \"2021-07-12\",\n      \"end_date\": null,\n      \"title\": \"CTO\",\n      \"department\": \"Technology\",\n      \"monthly_salary\": 3810,\n      \"from_integration\": false\n    },\n    {\n      \"_id\": \"789\",\n      \"name\": \"Psalm West\",\n      \"start_date\": \"2021-07-12\",\n      \"end_date\": null,\n      \"title\": \"CFO\",\n      \"department\": \"Finance\",\n      \"monthly_salary\": 3810,\n      \"from_integration\": false\n    },\n    {\n      \"_id\": \"41226058700031650054844085539491510251\",\n      \"name\": \"Isaiah Berlin\",\n      \"start_date\": \"2021-07-12\",\n      \"end_date\": null,\n      \"title\": \"Client Support Manager\",\n      \"department\": \"Sales\",\n      \"monthly_salary\": 3810,\n      \"from_integration\": true\n    },\n    {\n      \"_id\": \"109171277485994239594311564213702217202\",\n      \"name\": \"Patricia Churchland\",\n      \"start_date\": \"2021-07-12\",\n      \"end_date\": null,\n      \"title\": \"Account Director\",\n      \"department\": \"Sales\",\n      \"monthly_salary\": 6500,\n      \"from_integration\": true\n    },\n    {\n      \"_id\": \"329683582745307538665093187497664260298\",\n      \"name\": \"Soren Kierkegaard\",\n      \"start_date\": \"2021-07-12\",\n      \"end_date\": null,\n      \"title\": \"Client Support Director\",\n      \"department\": \"Marketing\",\n      \"monthly_salary\": 5833,\n      \"from_integration\": true\n    },\n    {\n      \"_id\": \"140447957202207332458650830288626240162\",\n      \"name\": \"Hannah Arendt\",\n      \"start_date\": \"2021-07-12\",\n      \"end_date\": null,\n      \"title\": \"Account Manager\",\n      \"department\": \"Marketing\",\n      \"monthly_salary\": 5083,\n      \"from_integration\": true\n    }\n  ]\n</code></pre>"},{"location":"oauth_authentication/","title":"OAuth 2.0 Authentication","text":"<p>Zebbra uses the OAuth 2.0 protocol to authenticate the user during requests. In this guide we provide examples of how to make requests to the API using  OAuth authentication.</p>  <p>You will need to install the Python <code>requests</code> module to run the examples</p>"},{"location":"oauth_authentication/#registering-a-new-user","title":"Registering a new user","text":"<p>To register a new user, you don't need to authenticat yourself. Instead, send the data of the new user to the <code>/register</code> endpoint, like so:</p> <pre><code>import requests\nimport json\n\nform_data = {\n  \"username\": \"charlie_brown@example.com\",\n  \"first_name\": \"Charlie\",\n  \"last_name\": \"Brown\",\n  \"new_workspace_name\": \"My Workspace\",\n  \"password\": \"secret\"\n}\n\nr = requests.post(\n    \"http://localhost:8000/register\",\n    data=json.dumps(form_data),\n)\n\nprint(r.json())\n\n# {\n#     '_id': '62d6c3de8688a74266d6c464', \n#     'username': 'charlie_brown@example.com',\n#     'first_name': 'Charlie', \n#     'last_name': 'Brown', \n#     'workspaces': [\n#         {\n#             '_id': '62d6c3de8688a74266d6c465', \n#             'name': 'My Workspace'\n#         }\n#     ], \n#     'models': []\n# }\n</code></pre> <p>You can now use the specified credentials <code>username = charlie_brown@example.com</code> and <code>password = secret</code> to request and OAuth access token.</p>"},{"location":"oauth_authentication/#getting-an-access-token","title":"Getting an access token","text":"<p>OAuth access tokens are used to authenticate the user who's sending the request. To get a token, send a POST request to the <code>/token</code> endpoint with your credentials in the body, like so:</p> <pre><code>r = requests.post(\n        'http://localhost:8000/token', \n        data={\n            'username': 'charlie_brown@example.com', \n            'password': 'secret'\n        }\n    )\n\nprint(r.json())\n\n# {\n#   'access_token': 'eyJhbGciO...', \n#   'token_type': 'bearer'\n# }\n</code></pre> <p>Use the <code>access_token</code> returned in the response in future requests.</p>"},{"location":"oauth_authentication/#using-the-access-token","title":"Using the access token","text":"<p>For example, the user can access the <code>/user</code> endpoint to retrieve user information about themselves. To use the OAuth access token, add an authorization header with the access token from the previous step, like so:</p> <pre><code>r = requests.get(\n    \"http://localhost:8000/user\", \n    headers={\n        \"Authorization\": f\"Bearer eyJhbGciO...\"\n    }\n)\n\nprint(r.json())\n\n# {\n#     '_id': '62d6c3de8688a74266d6c464', \n#     'username': 'charlie_brown@example.com',\n#     'first_name': 'Charlie', \n#     'last_name': 'Brown', \n#     'workspaces': [\n#         {\n#             '_id': '62d6c3de8688a74266d6c465', \n#             'name': 'My Workspace'\n#         }\n#     ], \n#     'models': []\n# }\n</code></pre>"},{"location":"oauth_authentication/#checking-for-token-expiry","title":"Checking for token expiry","text":"<p>For security reasons, access tokens expire after 30 minutes. If you use an expired access token, the authentication will not succeed. Thus, to determine if your current access token is still valid, you can send a GET request to the <code>/token/expired</code> endpoint.</p> <pre><code>r = requests.get(\n    \"http://localhost:8000/token/expired\", \n    headers={\n        \"Authorization\": f\"Bearer eyJhbGciO...\"\n    }\n)\n\nprint(r.json())\n\n# {\n#     'expired': False\n# }\n</code></pre> <p>In this case, the token is not yet expired. If <code>'expired': True</code>, you have to request a new access token from the <code>/token</code> endpoint, as previously seen.</p>"},{"location":"project_setup/","title":"Project Setup","text":"<p>This guide walks through the process of setting up Zebbra locally for development.</p>"},{"location":"project_setup/#prerequisites","title":"Prerequisites","text":"<p>To run Zebbra you will have to make sure the following is given on your machine (the versions matter!):</p> <ul> <li>Python 3.10 is installed, we recommend pyenv (how to)</li> <li>Node 16 is installed (how to)</li> <li>MongoDB Community Edition 5.0 is installed and running (how to)</li> </ul>"},{"location":"project_setup/#repository","title":"Repository","text":"<p>Start by cloning the repository, setting up a virtual environment and installing the required dependencies.</p> <pre><code># clone the repository\ngit clone git@github.com:leo-pfeiffer/zebbra.git\n</code></pre>"},{"location":"project_setup/#backend-setup","title":"Backend setup","text":"<p>We start by setting up the backend, that is the API server, as well as the database.</p> <p>First, create a virtual environment in the <code>server</code> directory <pre><code># zebbra/server\n\npython -m venv venv\nsource venv/bin/activate\n</code></pre></p> <p>Next, use the <code>make</code> command to install all package requirements via pip.</p> <pre><code># zebbra/server\n\n# install dependencies\nmake requirements\n</code></pre>"},{"location":"project_setup/#env-file","title":"<code>.env</code> file","text":"<p>Next, create the <code>.env</code> file with the environment variables. Run the following to create a file with the starter template. You will have to fill out the missing variable assignments (e.g. secrets etc.).</p> <pre><code># zebbra/server\n\ncat &lt;&lt;EOF &gt; .env\n# VALIDATION\nENV_SET=\"true\"\n\n# BASE URL\nZEBBRA_BASE_URL=\"http://localhost:8000\"\n\n# SETTINGS\nENV_ENCRYPT_PASS=\n\n# AUTH\nAUTH_SECRET=\nAUTH_ALGO=\"HS256\"\n# 30 days in minutes\nAUTH_TOKEN_EXPIRE=43200\n\n# MONGO DB\nMONGODB_USER=\nMONGODB_DB=\nMONGODB_PW=\nMONGODB_URL=\"127.0.0.1:27017\"\n\n# XERO\nXERO_CLIENT_ID=\nXERO_CLIENT_SECRET=\n\n# GUSTO\nGUSTO_CLIENT_ID=\nGUSTO_CLIENT_SECRET=\n\n# CACHE\n# 24 hrs in seconds\nCACHE_TTL=86400\nEOF\n</code></pre>"},{"location":"project_setup/#database","title":"Database","text":"<p>If you've set up the <code>.env</code> file correctly, you can use the default script to set up the database.</p> <pre><code># zebbra/server\n\nmake setup_db\n</code></pre> <p>This creates the required users, sets up the indexes for caching, and loads some demo data.</p>"},{"location":"project_setup/#run-the-server","title":"Run the server","text":"<p>At this point you should be able to run the app with the provided <code>run_server</code> command on port 8000.</p> <pre><code># zebbra/server\n\nmake run_server\n</code></pre>"},{"location":"project_setup/#testing","title":"Testing","text":"<p>If you want to run the unit tests for the backend you can now do so like this:</p> <pre><code># zebbra/server\n\nmake test\n</code></pre>"},{"location":"project_setup/#client-setup","title":"Client setup","text":"<p>Setting up the client is comparatively straightforward. </p>"},{"location":"project_setup/#install-requirements","title":"Install requirements","text":"<p>Start by installing the node modules from the <code>webclient</code> directory.</p> <pre><code># zebbra/webclient\n\nnpm install\n</code></pre>"},{"location":"project_setup/#env-file_1","title":"<code>.env</code> file","text":"<p>Like the server, the client requires a simple <code>.env</code> file. You can create it with the following command.</p> <pre><code># zebbra/webclient\n\ncat &lt;&lt;EOF &gt; .env\n# URLS\nFRONTEND_URL_BASE=\"http://localhost:3000\"\nBACKEND_URL_BASE=\"http://localhost:8000\"\nEOF\n</code></pre>"},{"location":"project_setup/#build-and-run-the-client","title":"Build and run the client","text":"<p>Lastly, we can build and run the client, like so:</p> <pre><code># zebbra/webclient\n\nnpm run dev\n</code></pre> <p>The client will be served on <code>http://localhost:3000</code>.</p>"},{"location":"project_setup/#testing_1","title":"Testing","text":"<p>If you want to run the unit tests for the frontend you can now do so like this.</p> <pre><code># zebbra/webclient\n\nnpm run test\n</code></pre>"},{"location":"tutorial/","title":"Zebbra Tutorial","text":""},{"location":"tutorial/#explainer-video","title":"Explainer video","text":"<p>Watch this short explainer video to get a feel for what you can do with Zebbra and how to interact with the application.</p>"}]}